# 创建项目

`npm init vue@latest`

配置项目的icon、标题及jsconfig.json文件

# 项目目录结构划分

src=>	assets静态资源

​		 	 components =>   common多项目共用   content当前项目多页面共用

​			  hooks

​		 	 mock

​	  		router

​		 	 service

​			  store

​			  utils

​		 	 views

# CSS样式的重置

`npm install --save normalize.css`

导入自己的reset.css、common.css文件

在css文件中创建index.css，引入上述文件`@import "./reset.css"`

main.js中`import "./assets/css/index.css"`

# 路由配置

`npm install vue-router`

```js
import {createRouter,createWebHashHistory} from 'vue-router'

const router=createRouter({
    history:createWebHashHistory(),
    routes:[
        {
            path:"/",
            redirect:"/home"
        },
        {
            path:"/home",
            component:()=>import("@/views/home/home.vue")
        },
        {
            path:"/favor",
            component:()=>import("@/views/favor/favor.vue")
        },
        {
            path:"/message",
            component:()=>import("@/views/message/message.vue")
        },
        {
            path:"/order",
            component:()=>import("@/views/order/order.vue")
        }
    ]
})

export default router
```

main.js里导入`import router from './router'`（不用写index.js，webpack自动找到）。`app.use(router)`

# 状态管理配置

`npm install pinia`

```js
import { createPinia } from "pinia";

const pinia=createPinia()

export default pinia
```

main.js中`import pinia  from './stores'`、`app.use(pinia)`

# tabbar加载本地图片路径问题

```vue
<template v-for="(item, index) in tabbarData">
        <img :src="item.img" alt="圖片" />  <!--这里的item.img错误-->
        <span class="text">{{ item.text }}</span>
</template>
```

由于把tabbarData抽离到单独页面并暴露，这里在tabbarData中img路径再写作“@/../../”发现组件中循环遍历不到。

若是webpack打包可以使用

```vue
<img :src="require(item.img)" alt="圖片" />
```

若是vite打包，需要在utils里封装路径转化工具

```js
export const getAssetURL=(img)=>{
    //参数一：相对路径
    //参数二：当前路径的URL
    return new URL(`../../assets/img/${image}`,import.meta.url).href
}
```

# tabbar在某些页面中隐藏问题

## 方案一

在路由中写meta

```js
{
    path:"/city",
        component:()=>import("@/views/city/city.vue"),
        meta:{
            hideTabbar:true  
        }
}
```

在App.vue中写

```vue
<template>
	<tab-bar v-if="!route.meta.hideTabbar"/> /*在这里拿具体属性，因为在js中拿就不是响应式了*/
</template>

<script setup>
    import { useRoute } from 'vue-Router'
	const route=useRoute() //useRoute是拿的当前活跃的路由对象。
</script>
```

## 方案二

City.vue中改写样式将tabbar盖掉

```css
.city {
    position:relative;
    z-index:9;
    height:100vh;
    background-color:#fff;
    overflow-y:auto
}
```

# 请求数据与展示

先在service里的request文件夹下二次封装axios

```js
import axios from 'axios'

class SRequest {
    constructor(baseURL,timeout=10000){
        this.instance=axios.create({
            baseURL,
            timeout
        })
    }

    request(config){
        return new Promise((resolve,reject)=>{
            this.instance.request(config).then(res=>{
                resolve(res.data)
            }).catch(err=>{
                reject(err)
            })
        })
    }

    get(config){
        return this.request({...config,method:"get"})
    }

    post(config){
        return this.request({...config,method:"post"})
    }
}

export default new SRequest()
```

书写request文件下的config.js文件配置基础路径和超时时间

```js
export const BASE_URL="http://codercba.com:1888/api"
export const TIMEOUT=10000
```

在service→modules→city.js中书写city.vue组件中所有的请求，写作方法便于使用

```js
import SRequest from '../request'
import { BASE_URL } from '../request/config'

export function getCityAll(){
    return SRequest.get({
        url:BASE_URL+"/city/all"
    })
}
```

在service→index.js暴露所有的modules子文件

```js
export * from "./modules/city"
```

在pinia中即store...modules...city.js中用actions管理发请求操作

```js
import { getCityAll } from "@/services";
import { defineStore } from "pinia";

export const useCityStore=defineStore("city",{
    state:()=>({
        allCities:[]
    }),
    actions:{
        async fetchAllCitiesData(){
            const res=await getCityAll()
            this.allCities=res.data
        }
    }
})
```

在city.vue组件在利用pinia获取数据

```js
const cityStore=useCityStore()
cityStore.fetchAllCitiesData()
const {allCities} = storeToRefs(cityStore)
```

在模板中遍历展示

```html
<!-- 对象遍历v-for="(v,k,i) in 对象" -->
        <template v-for="(value,key,index) in allCities" :key="key">
            <van-tab :title=value.title></van-tab>
        </template>
```

# 导航黏性定位？No！

更简单的做法：把下面滚动的内容计算成视口高度减去导航高度，再设置overflow-y:auto即可

```css
    .city {
        .content {
            height: calc(100vh - 98px);
            overflow-y: auto;
        }
    }
```

# 获取具体的城市数据

首先要拿到导航上选中的国内/海外的城市数据

//1.获取正确的key:将tabs中绑定的tabAction绑定到遍历对象的值（国内or海外？）上

//2.根据key从allCities获取数据。默认获取的数据非响应式，所以包裹个计算属性

```js
const tabActive=ref()
const currentGroup=computed(()=>allCities.value[tabActive.value])
```

再将拿到的数据封装成组件塞进city→cpns→city-group.vue

这里用到了父子通信props

```vue
<template>
  <div class="city-group">
    <template v-for="(group,index) in groupData.cities" :key="index">
        <div class="group-item">
            <h2 class="title">标题：{{ group.group }}</h2>
            <div class="list">
                <template v-for="(city,indey) in group.cities" :key="indey">
                    <div class="city">
                        {{ city.cityName }}
                     </div>
                </template>
            </div>
        </div>
    </template>
  </div>
</template>

<script setup>

defineProps({
    groupData:{
        type:Object,
        default:()=>({})
    }
})
</script>
```

city.vue中传数据<city-group :group-data="currentGroup"/>

# 子父传递

城市详情页面点击具体城市名字要传递到首页展示，这里可以用事件总线或者pinia管理。

使用pinia：

在子组件中给城市名绑定点击事件cityClick传入参数city，具体函数实现如下：

```js
const router=useRouter()
const cityStore=useCityStore()
function cityClick(city){
    //获取当前选中的城市存入pinia
    cityStore.currentCity=city
    //返回上一级路由
    router.back()
}
```

在pinia中state多添一个值currentCity，并将北京设为默认值

```js
state:()=>({
        currentCity:{cityName:"北京"}
    })
```

在父组件中直接拿到数据后显示

```js
const cityStore=useCityStore()
const { currentCity }=storeToRefs(cityStore)
```

# Query传参--搜索跳转

```js
//搜索按钮点击事件
function searchBtnClick(){
  router.push({
    path:"/search",
    query:{
      startDate:startDate.value,
      endDate:endDate.value,
      currentCity:currentCity.value.cityName
    }
  })
}
```

```js
//搜索页面展示数据
{{ $route.query.startDate }}
{{ $route.query.endDate }}
{{ $route.query.currentCity }}
```

# 异步请求

以发送请求详情为例

先在service/moudles/home.js中编写Request请求方法

```js
import SRquest from '../request'

export function getHomeCategories(){
    return SRquest.get({
        url:"/home/categories"
    })
}
```

在stores/modules/home.js中里actions发送请求

```js
actions:{
        async fetchCategoriesData(){
            const res=await getHomeCategories()
            console.log(res.data);
        }
    }
```

在views/home/home.vue中发送请求

```js
import { useHomeStore } from '@/stores/modules/home';

const homeStore=useHomeStore()
homeStore.fetchCategoriesData()
```

把获得的数据存入pinia中的state

```js
import { defineStore } from "pinia";
import { getHomeCategories } from "@/services";

export const useHomeStore=defineStore("home",{
    state:()=>({
        categories:[]
    }),
    actions:{
        async fetchCategoriesData(){
            const res=await getHomeCategories()
            this.categories=res.data
        }
    }
})
```

# v3展示pinia中数据

```js
import { useHomeStore } from "@/stores/modules/home";
import { storeToRefs } from "pinia";

const homeStore = useHomeStore();
const { categories } = storeToRefs(homeStore);
```

